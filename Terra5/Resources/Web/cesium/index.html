<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terra5 Globe</title>

    <!-- Cesium.js -->
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.114/Build/Cesium/Widgets/widgets.css" rel="stylesheet">

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0a0a0a;
        }

        #cesiumContainer {
            width: 100%;
            height: 100%;
            background: #0a0a0a;
        }

        /* Hide Cesium default UI elements */
        .cesium-viewer-toolbar,
        .cesium-viewer-animationContainer,
        .cesium-viewer-timelineContainer,
        .cesium-viewer-bottom,
        .cesium-viewer-fullscreenContainer,
        .cesium-credit-logoContainer,
        .cesium-credit-textContainer {
            display: none !important;
        }

        /* Custom styling for any remaining Cesium elements */
        .cesium-widget-credits {
            display: none !important;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer"></div>

    <script>
        // Terra5 Globe Controller
        const Terra5 = {
            viewer: null,
            dataSources: {},
            currentMode: 'normal',
            postProcessStages: [],

            // Initialize Cesium viewer
            init() {
                // Use default imagery (no Ion token required for basic functionality)
                // For production, add your Cesium Ion token here:
                // Cesium.Ion.defaultAccessToken = 'YOUR_TOKEN';

                this.viewer = new Cesium.Viewer('cesiumContainer', {
                    // Use ArcGIS World Imagery (freely accessible)
                    imageryProvider: new Cesium.ArcGisMapServerImageryProvider({
                        url: 'https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer'
                    }),
                    baseLayerPicker: false,
                    geocoder: false,
                    homeButton: false,
                    sceneModePicker: false,
                    navigationHelpButton: false,
                    animation: false,
                    timeline: false,
                    fullscreenButton: false,
                    vrButton: false,
                    selectionIndicator: false,
                    infoBox: false,
                    shouldAnimate: true,
                    skyBox: false,
                    skyAtmosphere: new Cesium.SkyAtmosphere()
                });

                // Dark styling
                this.viewer.scene.backgroundColor = Cesium.Color.fromCssColorString('#0a0a0a');
                this.viewer.scene.globe.baseColor = Cesium.Color.fromCssColorString('#0a0a0a');
                this.viewer.scene.globe.enableLighting = false;
                this.viewer.scene.fog.enabled = true;
                this.viewer.scene.fog.density = 0.0001;

                // Atmosphere styling
                if (this.viewer.scene.skyAtmosphere) {
                    this.viewer.scene.skyAtmosphere.brightnessShift = -0.3;
                    this.viewer.scene.skyAtmosphere.saturationShift = -0.5;
                }

                // Initialize data sources
                this.dataSources.flights = new Cesium.CustomDataSource('flights');
                this.dataSources.satellites = new Cesium.CustomDataSource('satellites');
                this.dataSources.earthquakes = new Cesium.CustomDataSource('earthquakes');

                Object.values(this.dataSources).forEach(ds => {
                    this.viewer.dataSources.add(ds);
                });

                // Camera change listener
                this.viewer.camera.changed.addEventListener(() => {
                    this.notifyCameraChange();
                });

                // Click handler
                this.viewer.screenSpaceEventHandler.setInputAction((click) => {
                    const pickedObject = this.viewer.scene.pick(click.position);
                    if (Cesium.defined(pickedObject) && pickedObject.id) {
                        this.notifyEntityClick(pickedObject.id);
                    }
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                // Initial camera position (Washington DC)
                this.viewer.camera.setView({
                    destination: Cesium.Cartesian3.fromDegrees(-77.0369, 38.9072, 10000000)
                });

                // Notify Swift that globe is ready
                this.sendToSwift('globeReady', { ready: true });

                console.log('Terra5 Globe initialized');
            },

            // Camera operations
            flyTo(lat, lon, alt, duration = 2.0) {
                this.viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(lon, lat, alt),
                    duration: duration,
                    easingFunction: Cesium.EasingFunction.QUADRATIC_IN_OUT
                });
            },

            notifyCameraChange() {
                const cartographic = this.viewer.camera.positionCartographic;
                this.sendToSwift('cameraChanged', {
                    latitude: Cesium.Math.toDegrees(cartographic.latitude),
                    longitude: Cesium.Math.toDegrees(cartographic.longitude),
                    altitude: cartographic.height,
                    heading: Cesium.Math.toDegrees(this.viewer.camera.heading)
                });
            },

            notifyEntityClick(entity) {
                if (entity && entity.properties) {
                    const props = {};
                    entity.properties.propertyNames.forEach(name => {
                        props[name] = entity.properties[name].getValue();
                    });
                    this.sendToSwift('entityClicked', props);
                }
            },

            // Data layer updates
            updateFlights(flights) {
                const ds = this.dataSources.flights;
                ds.entities.removeAll();

                flights.forEach(flight => {
                    if (!flight.longitude || !flight.latitude) return;

                    ds.entities.add({
                        id: flight.icao24,
                        position: Cesium.Cartesian3.fromDegrees(
                            flight.longitude,
                            flight.latitude,
                            (flight.altitude || 0) + 100 // Slight elevation
                        ),
                        billboard: {
                            image: this.createAircraftSVG(flight.heading || 0),
                            width: 24,
                            height: 24,
                            color: Cesium.Color.fromCssColorString('#00d4aa')
                        },
                        label: {
                            text: flight.callsign || flight.icao24,
                            font: '11px Menlo, monospace',
                            fillColor: Cesium.Color.fromCssColorString('#00d4aa'),
                            outlineColor: Cesium.Color.BLACK,
                            outlineWidth: 2,
                            style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                            pixelOffset: new Cesium.Cartesian2(0, -20),
                            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 500000)
                        },
                        properties: flight
                    });
                });

                this.sendToSwift('dataUpdated', {
                    layer: 'flights',
                    count: flights.length
                });
            },

            updateSatellites(satellites) {
                const ds = this.dataSources.satellites;
                ds.entities.removeAll();

                satellites.forEach(sat => {
                    if (!sat.longitude || !sat.latitude) return;

                    ds.entities.add({
                        id: `sat-${sat.noradId}`,
                        position: Cesium.Cartesian3.fromDegrees(
                            sat.longitude,
                            sat.latitude,
                            (sat.altitude || 400) * 1000 // km to meters
                        ),
                        point: {
                            pixelSize: 6,
                            color: Cesium.Color.fromCssColorString('#00ffaa'),
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 1
                        },
                        label: {
                            text: sat.name,
                            font: '10px Menlo, monospace',
                            fillColor: Cesium.Color.fromCssColorString('#00ffaa'),
                            pixelOffset: new Cesium.Cartesian2(10, 0),
                            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 5000000)
                        },
                        properties: sat
                    });
                });

                this.sendToSwift('dataUpdated', {
                    layer: 'satellites',
                    count: satellites.length
                });
            },

            updateEarthquakes(earthquakes) {
                const ds = this.dataSources.earthquakes;
                ds.entities.removeAll();

                earthquakes.forEach(eq => {
                    if (!eq.longitude || !eq.latitude) return;

                    const size = Math.max(10000, eq.magnitude * 20000);

                    ds.entities.add({
                        id: `eq-${eq.id}`,
                        position: Cesium.Cartesian3.fromDegrees(eq.longitude, eq.latitude),
                        ellipse: {
                            semiMinorAxis: size,
                            semiMajorAxis: size,
                            material: Cesium.Color.fromCssColorString('#ff4444').withAlpha(0.5),
                            outline: true,
                            outlineColor: Cesium.Color.fromCssColorString('#ff4444'),
                            outlineWidth: 2
                        },
                        label: {
                            text: `M${eq.magnitude.toFixed(1)}`,
                            font: '11px Menlo, monospace',
                            fillColor: Cesium.Color.fromCssColorString('#ff4444'),
                            pixelOffset: new Cesium.Cartesian2(0, -20),
                            distanceDisplayCondition: new Cesium.DistanceDisplayCondition(0, 2000000)
                        },
                        properties: eq
                    });
                });

                this.sendToSwift('dataUpdated', {
                    layer: 'earthquakes',
                    count: earthquakes.length
                });
            },

            // Layer visibility
            setLayerVisibility(layer, visible) {
                if (this.dataSources[layer]) {
                    this.dataSources[layer].show = visible;
                }
            },

            // Visual modes
            setVisualMode(mode) {
                this.currentMode = mode;

                // Remove existing post-process stages
                this.viewer.scene.postProcessStages.removeAll();

                switch(mode) {
                    case 'crt':
                        this.applyCRTEffect();
                        break;
                    case 'nvg':
                        this.applyNVGEffect();
                        break;
                    case 'flir':
                        this.applyFLIREffect();
                        break;
                    case 'noir':
                        this.applyNoirEffect();
                        break;
                    case 'anime':
                        this.applyAnimeEffect();
                        break;
                    case 'snow':
                        this.applySnowEffect();
                        break;
                    default:
                        // Normal mode - no post-processing
                        break;
                }
            },

            applyCRTEffect() {
                const stage = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        in vec2 v_textureCoordinates;

                        void main() {
                            vec2 uv = v_textureCoordinates;
                            vec4 color = texture(colorTexture, uv);

                            // Scanlines
                            float scanline = sin(uv.y * 800.0) * 0.04;
                            color.rgb -= scanline;

                            // Green tint
                            color.r *= 0.85;
                            color.b *= 0.85;
                            color.g *= 1.1;

                            // Vignette
                            float vignette = 1.0 - length((uv - 0.5) * 1.3);
                            color.rgb *= vignette;

                            // Chromatic aberration
                            float aberration = 0.001;
                            color.r = texture(colorTexture, uv + vec2(aberration, 0.0)).r * 0.85;
                            color.b = texture(colorTexture, uv - vec2(aberration, 0.0)).b * 0.85;

                            out_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(stage);
            },

            applyNVGEffect() {
                const stage = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        in vec2 v_textureCoordinates;

                        void main() {
                            vec4 color = texture(colorTexture, v_textureCoordinates);

                            // Convert to luminance
                            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));

                            // Green phosphor color
                            vec3 nvg = vec3(0.0, luma * 1.3, luma * 0.1);

                            // Add noise
                            float noise = fract(sin(dot(v_textureCoordinates * 1000.0, vec2(12.9898, 78.233))) * 43758.5453);
                            nvg += noise * 0.05;

                            // Boost contrast
                            nvg = pow(nvg, vec3(0.85));

                            // Slight vignette
                            float vignette = 1.0 - length((v_textureCoordinates - 0.5) * 0.8);
                            nvg *= vignette;

                            out_FragColor = vec4(nvg, 1.0);
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(stage);
            },

            applyFLIREffect() {
                const stage = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        in vec2 v_textureCoordinates;

                        void main() {
                            vec4 color = texture(colorTexture, v_textureCoordinates);
                            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));

                            // Thermal color gradient (black -> purple -> red -> yellow -> white)
                            vec3 thermal;
                            if (luma < 0.25) {
                                thermal = mix(vec3(0.0, 0.0, 0.1), vec3(0.3, 0.0, 0.4), luma * 4.0);
                            } else if (luma < 0.5) {
                                thermal = mix(vec3(0.3, 0.0, 0.4), vec3(0.8, 0.2, 0.0), (luma - 0.25) * 4.0);
                            } else if (luma < 0.75) {
                                thermal = mix(vec3(0.8, 0.2, 0.0), vec3(1.0, 0.9, 0.0), (luma - 0.5) * 4.0);
                            } else {
                                thermal = mix(vec3(1.0, 0.9, 0.0), vec3(1.0, 1.0, 1.0), (luma - 0.75) * 4.0);
                            }

                            out_FragColor = vec4(thermal, 1.0);
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(stage);
            },

            applyNoirEffect() {
                const stage = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        in vec2 v_textureCoordinates;

                        void main() {
                            vec4 color = texture(colorTexture, v_textureCoordinates);
                            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));

                            // High contrast B&W
                            luma = pow(luma, 0.7);
                            luma = smoothstep(0.1, 0.9, luma);

                            // Slight sepia tint
                            vec3 noir = vec3(luma * 1.0, luma * 0.95, luma * 0.9);

                            // Vignette
                            float vignette = 1.0 - length((v_textureCoordinates - 0.5) * 1.2);
                            noir *= vignette;

                            out_FragColor = vec4(noir, 1.0);
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(stage);
            },

            applyAnimeEffect() {
                const stage = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        in vec2 v_textureCoordinates;

                        void main() {
                            vec4 color = texture(colorTexture, v_textureCoordinates);

                            // Posterize colors
                            float levels = 6.0;
                            color.rgb = floor(color.rgb * levels) / levels;

                            // Boost saturation
                            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                            color.rgb = mix(vec3(luma), color.rgb, 1.5);

                            // Edge detection for outlines
                            vec2 texelSize = 1.0 / vec2(1920.0, 1080.0);
                            float edge = 0.0;
                            for (int x = -1; x <= 1; x++) {
                                for (int y = -1; y <= 1; y++) {
                                    if (x == 0 && y == 0) continue;
                                    vec4 neighbor = texture(colorTexture, v_textureCoordinates + vec2(float(x), float(y)) * texelSize * 2.0);
                                    edge += length(color.rgb - neighbor.rgb);
                                }
                            }
                            edge = edge > 0.3 ? 1.0 : 0.0;

                            // Apply dark outline
                            color.rgb = mix(color.rgb, vec3(0.0), edge * 0.5);

                            out_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(stage);
            },

            applySnowEffect() {
                const stage = new Cesium.PostProcessStage({
                    fragmentShader: `
                        uniform sampler2D colorTexture;
                        in vec2 v_textureCoordinates;

                        void main() {
                            vec4 color = texture(colorTexture, v_textureCoordinates);

                            // Desaturate
                            float luma = dot(color.rgb, vec3(0.299, 0.587, 0.114));
                            color.rgb = mix(color.rgb, vec3(luma), 0.7);

                            // Blue tint
                            color.r *= 0.85;
                            color.g *= 0.92;
                            color.b *= 1.15;

                            // Brighten
                            color.rgb = pow(color.rgb, vec3(0.9));

                            // Add subtle noise (snow static)
                            float noise = fract(sin(dot(v_textureCoordinates * 500.0, vec2(12.9898, 78.233))) * 43758.5453);
                            color.rgb += noise * 0.02;

                            out_FragColor = color;
                        }
                    `
                });
                this.viewer.scene.postProcessStages.add(stage);
            },

            // Create aircraft icon SVG
            createAircraftSVG(heading) {
                const canvas = document.createElement('canvas');
                canvas.width = 32;
                canvas.height = 32;
                const ctx = canvas.getContext('2d');

                ctx.translate(16, 16);
                ctx.rotate((heading || 0) * Math.PI / 180);
                ctx.translate(-16, -16);

                ctx.fillStyle = '#00d4aa';
                ctx.beginPath();
                ctx.moveTo(16, 4);
                ctx.lineTo(24, 28);
                ctx.lineTo(16, 22);
                ctx.lineTo(8, 28);
                ctx.closePath();
                ctx.fill();

                return canvas.toDataURL();
            },

            // Bridge to Swift
            sendToSwift(handler, data) {
                if (window.webkit && window.webkit.messageHandlers && window.webkit.messageHandlers[handler]) {
                    window.webkit.messageHandlers[handler].postMessage(data);
                }
            }
        };

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            Terra5.init();
        });
    </script>
</body>
</html>
